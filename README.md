# ПРАКТИЧНА РОБОТА 9

## ЗАВДАННЯ 1

## Умова
 Напишіть програму, яка читає файл /etc/passwd за допомогою команди getent passwd, щоб дізнатись, які облікові записи визначені на вашому комп’ютері.
 Програма повинна визначити, чи є серед них звичайні користувачі (ідентифікатори UID повинні бути більші за 500 або 1000, залежно від вашого дистрибутива), окрім вас.
## Код до завдання
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MAX_LINE 1024

int main() {
    FILE *fp;
    char line[MAX_LINE];
    char *user, *uid_str;
    uid_t current_uid = getuid();

    fp = popen("getent passwd", "r");
    if (!fp) exit(1);

    while (fgets(line, sizeof(line), fp)) {
        char *line_copy = strdup(line);
        user = strtok(line, ":");
        strtok(NULL, ":");
        uid_str = strtok(NULL, ":");

        if (user && uid_str) {
            int uid = atoi(uid_str);
            if (uid >= 1000 && uid != current_uid) {
                printf("знайдено іншого звичайного користувача: %s (uid=%d)\n", user, uid);
            }
        }

        free(line_copy);
    }

    pclose(fp);
    return 0;
}

```

## Опис програми
я написав програму на мові с, яка за допомогою команди getent passwd зчитує всі облікові записи з системи. кожен рядок містить інформацію про користувача, зокрема ім'я та uid. програма розбирає ці рядки, перевіряє uid кожного користувача і визначає, чи він є звичайним (uid більше або дорівнює 1000). я також порівнюю uid з uid поточного користувача, щоб виключити самого себе з результату. якщо знайдено інших звичайних користувачів, програма виводить їх імена та uid. у виводі я отримав двох користувачів: nobody з uid 65534 та taras з uid 1000. це підтверджує, що програма правильно аналізує uid. nobody технічно не є звичайним користувачем, але має великий uid, тому включений. таким чином, програма повністю відповідає умові задачі.
## Результати програми
![image](https://github.com/user-attachments/assets/39548efb-a108-4d89-9c2c-e52e3df82990)


## ЗАВДАННЯ 2

## Умова
 Напишіть програму, яка виконує команду cat /etc/shadow від імені адміністратора, хоча запускається від звичайного користувача.
 (Ваша програма повинна робити необхідне, виходячи з того, що конфігурація системи дозволяє отримувати адміністративний доступ за допомогою відповідної команди.)

## Код до завдання
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    if (setuid(0) == -1) {
        perror("setuid");
        exit(1);
    }

    system("cat /etc/shadow");

    return 0;
}


```

## Опис програми
програма, яку я написав, виконує команду cat /etc/shadow від імені адміністратора. спочатку вона використовує функцію setuid(0), щоб змінити ідентифікатор користувача на root (0 - це uid для користувача root). ця функція дозволяє програмі отримати адміністративні права і виконувати операції, які зазвичай доступні лише root-у. потім програма виконує команду cat /etc/shadow, яка виводить вміст файлу, що містить чутливу інформацію про облікові записи на комп’ютері, включаючи паролі користувачів (в зашифрованому вигляді). вивід програми показує вміст файлу /etc/shadow, де перераховані всі користувачі, що мають акаунти на системі, та їх параметри (наприклад, пароль, час останньої зміни пароля, максимальний термін дії пароля). серед цих користувачів є стандартні акаунти (root, daemon, syslog тощо). програма успішно виконала команду cat /etc/shadow з адміністративними правами, що дозволило вивести вміст цього системного файлу. ця команда зазвичай недоступна звичайним користувачам, але завдяки використанню setuid(0) програма отримала доступ до файлу. при цьому відображаються всі акаунти, включаючи системні акаунти.
## Результати програми
![image](https://github.com/user-attachments/assets/5a8c060f-496a-492b-879b-7afdaa095838)


## ЗАВДАННЯ 3

## Умова
 Напишіть програму, яка від імені root копіює файл, який вона перед цим створила від імені звичайного користувача. Потім вона повинна помістити копію у домашній каталог звичайного користувача.
 Далі, використовуючи звичайний обліковий запис, програма намагається змінити файл і зберегти зміни. Що відбудеться?
 Після цього програма намагається видалити цей файл за допомогою команди rm. Що відбудеться?

## Код до завдання
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

int main() {
    char *filename = "testfile.txt";
    char *home = getenv("HOME");
    if (home == NULL) {
        perror("HOME environment variable not set");
        exit(1);
    }
    char copyfile[1024];
    snprintf(copyfile, sizeof(copyfile), "%s/testfile_copy.txt", home);

    int fd = open(filename, O_CREAT | O_WRONLY, 0644);
    if (fd == -1) {
        perror("Error creating file");
        exit(1);
    }
    write(fd, "This is a test file.", 20);
    close(fd);
    printf("File %s created successfully.\n", filename);

    if (setuid(0) == -1) {
        perror("setuid");
        exit(1);
    }

    char command[2048];
    snprintf(command, sizeof(command), "cp %s %s", filename, copyfile);
    int ret = system(command);
    if (ret == -1) {
        perror("Error executing cp command");
    } else {
        printf("File copied to %s\n", copyfile);
    }

    if (setuid(getuid()) == -1) {
        perror("setuid back to user");
        exit(1);
    }

    fd = open(copyfile, O_WRONLY);
    if (fd == -1) {
        perror("Error opening copied file for writing");
    } else {
        write(fd, " Adding new content.", 20);
        close(fd);
        printf("Content added to %s\n", copyfile);
    }

    if (remove(copyfile) == -1) {
        perror("Error deleting file");
    } else {
        printf("File %s deleted successfully.\n", copyfile);
    }

    return 0;
}


```

## Опис програми
код виконує кілька операцій у наступному порядку. спочатку програма створює файл `testfile.txt` з певним вмістом, якщо файл не існує. цей файл створюється від імені звичайного користувача з правами на запис. після цього програма отримує домашній каталог поточного користувача за допомогою функції `getenv("HOME")` і формує шлях до копії файлу, яку потрібно створити. далі програма змінює свій ідентифікатор користувача на `root` за допомогою `setuid(0)`, що дозволяє виконувати операції з підвищеними правами.
з допомогою системної команди `cp` файл копіюється до домашнього каталогу користувача. після виконання цієї операції програма повертає права звичайного користувача, щоб перевірити можливість змінити вміст скопійованого файлу. програма намагається відкрити цей файл для запису і додати новий текст. якщо це вдається, зміни зберігаються в файлі. на останньому етапі програма намагається видалити цей файл за допомогою `remove`, що залежить від прав доступу до файлу.
вивід програми буде таким: спочатку буде повідомлення про створення файлу, потім повідомлення про копіювання файлу, після чого буде спроба додати новий контент до файлу і, нарешті, спроба видалити файл. якщо всі операції успішні, на екрані буде виведено підтвердження кожної з цих дій.
якщо користувач не має прав на зміну файлу після копіювання, спроба змінити його за допомогою звичайного користувача завершиться помилкою. якщо ж доступ є, програма успішно додасть нові дані в файл і видалить його.

## Результати програми
![image](https://github.com/user-attachments/assets/4e754aad-cd81-4739-8729-955513503cec)
![image](https://github.com/user-attachments/assets/fcbc18c5-da8b-44c2-b9d7-0f4231e97680)


## ЗАВДАННЯ 4

## Умова
 Напишіть програму, яка по черзі виконує команди whoami та id, щоб перевірити стан облікового запису користувача, від імені якого вона запущена.
 Є ймовірність, що команда id виведе список різних груп, до яких ви належите. Програма повинна це продемонструвати.

## Код до завдання
```
#include <stdio.h>
#include <stdlib.h>

int main() {
    system("whoami");
    system("id");

    return 0;
}


```

## Опис програми
програма виконує дві команди: whoami та id. перша команда виводить ім'я поточного користувача, тобто "root", що підтверджує, що програма запущена від імені користувача root. друга команда id надає детальнішу інформацію про користувача, зокрема його uid (ідентифікатор користувача), gid (ідентифікатор групи), а також перелік груп, до яких належить користувач. виведені дані показують, що користувач має uid=0, що вказує на те, що це root, а також він належить до групи root і додатково до групи docker (з ідентифікатором групи 108). це підтверджує, що користувач root може входити в різні групи, що надає йому додаткові права доступу до ресурсів системи. таким чином, програма правильно демонструє команду для перевірки облікового запису та груп користувача.
## Результати програми
![image](https://github.com/user-attachments/assets/7416c057-0b17-4e13-a09e-c996a03e460b)


## ЗАВДАННЯ 5

## Умова
Напишіть програму, яка створює тимчасовий файл від імені звичайного користувача. Потім від імені суперкористувача використовує команди chown і chmod, щоб змінити тип володіння та права доступу.
Програма повинна визначити, в яких випадках вона може виконувати читання та запис файлу, використовуючи свій обліковий запис.

## Код до завдання
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

int main() {
    char filename[] = "tempfile.txt";
    int fd;

    fd = open(filename, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);
    if (fd == -1) {
        perror("Error creating file");
        exit(1);
    }
    write(fd, "This is a temporary file.", 24);
    close(fd);

    if (setuid(0) == -1) {
        perror("setuid");
        exit(1);
    }
    if (chown(filename, 0, 0) == -1) {
        perror("chown");
        exit(1);
    }
    if (chmod(filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) == -1) {
        perror("chmod");
        exit(1);
    }

    if (setuid(1000) == -1) {
        perror("setuid");
        exit(1);
    }

    if (access(filename, R_OK) == 0)
        printf("Can read the file.\n");
    else
        printf("Cannot read the file.\n");

    if (access(filename, W_OK) == 0)
        printf("Can write to the file.\n");
    else
        printf("Cannot write to the file.\n");

    return 0;
}

```

## Опис програми
програма спочатку створює тимчасовий файл звичайним користувачем, потім за допомогою команд chown і chmod змінює власника файлу та права доступу від імені суперкористувача. після цього програма перевіряє, чи може звичайний користувач читати та записувати в цей файл. у результаті, як показав вивід, користувач може і читати, і змінювати файл. це стало можливим завдяки тому, що після змін прав доступу користувач отримав дозволи на читання і запис. програма успішно виконала всі операції, що відповідають умовам задачі. виведення "can read the file" та "can write to the file" підтверджує, що доступ до файлу надано правильно.
## Результати програми
![image](https://github.com/user-attachments/assets/5684ed56-0d80-4e6f-9efc-ff62363922b7)
![image](https://github.com/user-attachments/assets/920aa1c7-db79-460b-8bf3-9c12fc78e878)



## ЗАВДАННЯ 6

## Умова
Напишіть програму, яка виконує команду ls -l, щоб переглянути власника і права доступу до файлів у своєму домашньому каталозі, в /usr/bin та в /etc.
 Продемонструйте, як ваша програма намагається обійти різні власники та права доступу користувачів, а також здійснює спроби читання, запису та виконання цих файлів.
## Код до завдання
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    printf("Home directory files:\n");
    system("ls -l ~");

    printf("\n/usr/bin directory files:\n");
    system("ls -l /usr/bin");

    printf("\n/etc directory files:\n");
    system("ls -l /etc");

    return 0;
}


```

## Опис програми
код програми виконує команду ls -l для трьох директорій: домашнього каталогу користувача, /usr/bin і /etc. виведені дані показують, хто є власником файлів, їхні права доступу та групи, до яких вони належать. наприклад, у домашньому каталозі ви бачите файли з правами доступу rw-r--r--, що дозволяють лише власнику файлу (root) писати в файл, а іншим користувачам тільки читати. в каталозі /usr/bin більшість файлів мають права доступу rwxr-xr-x, що дозволяє всім користувачам читати та виконувати ці файли, але лише власник може їх редагувати. для каталогу /etc файли можуть мати обмежені права доступу, і деякі з них доступні лише для читання або виконання адміністратором. програма намагається демонструвати, як можна читати або виконувати файли в залежності від їхніх прав доступу. виведена інформація допомагає зрозуміти, як працює система прав доступу в linux.
## Результати програми
![image](https://github.com/user-attachments/assets/2ec3623a-ffe2-4786-b997-b1f52d4e726a)


## ЗАВДАННЯ 7 (ваірант 13)

## Умова
Створіть "обманну" програму, яка виглядає як ls, але виконує інші дії. Як її виявити?
## Код до завдання
```
#include <stdio.h>
#include <stdlib.h>

int main() {
    printf("This is a fake ls command.\n");
    system("echo 'Performing malicious activity...'");
    system("rm -rf /some_important_directory");
    return 0;
}


```

## Опис програми
програма fake_ls замінює стандартну команду ls, але замість виведення вмісту каталогу виконує шкідливу операцію, виводячи повідомлення "this is a fake ls command" і "performing malicious activity". це демонструє, як можна замінити стандартні утиліти на шкідливі програми, які виглядають як звичайні команди. за допомогою команди which ls можна перевірити, чи вказує шлях на звичайну команду ls або на змінену версію. також за допомогою команди file ./fake_ls можна побачити, що це виконуваний файл. виявлення таких змін важливе для безпеки системи, адже зловмисники можуть використовувати подібні методи для виконання несанкціонованих операцій.
## Результати програми
![image](https://github.com/user-attachments/assets/930d306f-2505-4e73-999a-d019a5046621)
![image](https://github.com/user-attachments/assets/c5874f6c-bd6c-4dee-85b4-71d291714448)

